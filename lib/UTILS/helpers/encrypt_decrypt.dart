// ignore_for_file: no_logic_in_create_state, non_constant_identifier_names

import 'package:encrypt/encrypt.dart' as encrypt;
// import 'package:get/get.dart';

// import '../../controllers/IAM_actions.dart';
// import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class AES {
  // final SessiontokenController sessiontokenController = Get.find<SessiontokenController>();
  // static String SESSIONTOKEN = "15b97917-b296-11ed-997a-b42e9923";

  /// Encrypts a given plain text string using AES (Advanced Encryption Standard) in CBC mode.
  ///
  /// This static method provides a symmetric encryption mechanism where the same key
  /// is used for both encryption and decryption. It specifically uses AES with
  /// Cipher Block Chaining (CBC) mode and a key-derived Initialization Vector (IV).
  ///
  /// **Parameters:**
  /// - `key`: The secret key as a `String` which must be 16, 24, or 32 bytes long when encoded as UTF-8
  ///          to be valid for AES-128, AES-192, or AES-256 respectively.
  /// - `plainText`: The `String` data that needs to be encrypted.
  ///
  /// **Process:**
  /// 1.  **Derive Cipher Key:**
  ///     - `final cipherKey = encrypt.Key.fromUtf8(key);` converts the provided `key` string
  ///       into a `Key` object, suitable for cryptographic operations, by encoding it as UTF-8.
  /// 2.  **Initialize Encrypter:**
  ///     - `final encrypter = encrypt.Encrypter(encrypt.AES(cipherKey, mode: encrypt.AESMode.cbc));`
  ///       creates an `Encrypter` instance. It is configured to use the AES algorithm
  ///       with the derived `cipherKey` and sets the encryption `mode` to `CBC` (Cipher Block Chaining).
  /// 3.  **Derive Initialization Vector (IV):**
  ///     - `final iv = encrypt.IV.fromUtf8(key.substring(0, 16));` creates an `IV` (Initialization Vector).
  ///       **Crucially, the IV is generated by taking the first 16 characters (16 bytes if UTF-8 is ASCII-compatible)
  ///       of the provided `key`.** In CBC mode, the IV is essential for randomness and to ensure that
  ///       identical plaintexts produce different ciphertexts. For AES, the IV length must be 16 bytes.
  ///       Using a portion of the key as the IV is a common practice, though for higher security,
  ///       a randomly generated IV is often preferred and transmitted alongside the ciphertext.
  /// 4.  **Perform Encryption:**
  ///     - `final encrypted = encrypter.encrypt(plainText, iv: iv);` performs the actual encryption.
  ///       The `plainText` is encrypted using the configured `encrypter` and the generated `iv`.
  /// 5.  **Encode to Base64:**
  ///     - `final encryptedBase64 = encrypted.base64;` converts the raw encrypted bytes into a
  ///       Base64 encoded string. This makes the encrypted data safe for transmission or storage
  ///       in text-based formats.
  /// 6.  **Return Encrypted String:**
  ///     - The Base64 encoded encrypted string is returned.
  ///
  /// **Important Considerations:**
  /// - **Key Management:** This function assumes the `key` is securely managed and shared between
  ///   encryption and decryption parties.
  /// - **IV Reusability:** Using a static portion of the key as the IV is simpler but **less secure**
  ///   than using a truly random and unique IV for each encryption operation. If the same IV and key
  ///   are reused for multiple encryptions, it can make the encryption vulnerable to attacks.
  ///   For production environments, generating a unique random IV per encryption and prepending
  ///   it to the ciphertext is generally recommended.
  /// - **Key Length:** Ensure the `key` string, when UTF-8 encoded, matches the required byte length
  ///   for the chosen AES variant (e.g., 16 bytes for AES-128). If the key is not the correct length,
  ///   the `encrypt` library might pad or truncate it, which could lead to unexpected behavior or errors.
  static String encryptWithAES(String key, String plainText) {
    final cipherKey = encrypt.Key.fromUtf8(key);
    final encrypter = encrypt.Encrypter(encrypt.AES(cipherKey, mode: encrypt.AESMode.cbc));
    final iv = encrypt.IV.fromUtf8(key.substring(0, 16)); // Use an IV with the correct length
    final encrypted = encrypter.encrypt(plainText, iv: iv);
    final encryptedBase64 = encrypted.base64;
    return encryptedBase64;
  }

  /// Decrypts a Base64 encoded string using AES (Advanced Encryption Standard) in CBC mode.
  ///
  /// This static method is the counterpart to `encryptWithAES`. It takes an
  /// encrypted, Base64 encoded string and a decryption key to recover the
  /// original plain text. It assumes the same key-derived Initialization Vector (IV)
  /// was used during encryption.
  ///
  /// **Parameters:**
  /// - `key`: The secret key as a `String` which must be 16, 24, or 32 bytes long when encoded as UTF-8
  ///          to be valid for AES-128, AES-192, or AES-256 respectively. This `key` must be the
  ///          same as the one used for encryption.
  /// - `encryptedData`: The `String` containing the Base64 encoded ciphertext that needs to be decrypted.
  ///
  /// **Process:**
  /// 1.  **Derive Cipher Key:**
  ///     - `final cipherKey = encrypt.Key.fromUtf8(key);` converts the provided `key` string
  ///       into a `Key` object, suitable for cryptographic operations, by encoding it as UTF-8.
  ///       This must be the exact same key used for encryption.
  /// 2.  **Initialize Decrypter:**
  ///     - `final encrypter = encrypt.Encrypter(encrypt.AES(cipherKey, mode: encrypt.AESMode.cbc));`
  ///       creates an `Encrypter` instance configured for AES decryption using the `cipherKey`
  ///       and specifying `CBC` (Cipher Block Chaining) mode. The mode must match the encryption mode.
  /// 3.  **Derive Initialization Vector (IV):**
  ///     - `final iv = encrypt.IV.fromUtf8(key.substring(0, 16));` creates the `IV` (Initialization Vector).
  ///       **It is critical that this IV is generated using the exact same logic as during encryption.**
  ///       Here, it re-derives the IV by taking the first 16 characters (16 bytes) of the `key`.
  ///       In CBC mode, the IV is essential for correct decryption.
  /// 4.  **Prepare Encrypted Data:**
  ///     - `final encrypted = encrypt.Encrypted.fromBase64(encryptedData);` converts the Base64
  ///       encoded `encryptedData` string back into an `Encrypted` object, which contains
  ///       the raw encrypted bytes.
  /// 5.  **Perform Decryption:**
  ///     - `return encrypter.decrypt(encrypted, iv: iv);` performs the actual decryption.
  ///       The `encrypted` data is decrypted using the configured `encrypter` and the derived `iv`.
  /// 6.  **Return Decrypted Plain Text:**
  ///     - The decrypted plain text string is returned.
  ///
  /// **Important Considerations:**
  /// - **Key and IV Consistency:** The `key` and the logic for deriving the IV must be
  ///   absolutely identical to what was used during encryption for successful decryption.
  ///   Any mismatch will result in incorrect or failed decryption.
  /// - **Error Handling:** If the `encryptedData` is malformed (not valid Base64) or the
  ///   key/IV combination does not match the original encryption, this function may throw
  ///   an error (e.g., `FormatException` for invalid Base64, or a cryptographic exception).
  ///   Robust applications should include `try-catch` blocks when calling this method.
  static String decryptWithAES(String key, String encryptedData) {
    final cipherKey = encrypt.Key.fromUtf8(key);
    final encrypter = encrypt.Encrypter(encrypt.AES(cipherKey, mode: encrypt.AESMode.cbc));
    final iv = encrypt.IV.fromUtf8(key.substring(0, 16)); // Use an IV with the correct length

    final encrypted = encrypt.Encrypted.fromBase64(encryptedData);
    return encrypter.decrypt(encrypted, iv: iv);
  }

  // Future<String?> get_stored_token() async {
  //   return sessiontokenController.sessiontokenModel.sessiontokenController.value;
  // }
}
// .sessionModel.sessiontokenController.value;
//   Future<void> Token_write_Function(
//       Map<String, dynamic> decodedResponse) async {
//     final valueToToken = decodedResponse["Value"].toString();
//     await const FlutterSecureStorage().write(key: 'Value', value: valueToToken);
//   }

// //example
// //valueToToken : 7a9c070a-cb09-11ee-9b9f-b42e9923474d
//   Future<void> check_stored_token() async {
//     final valueToToken = await const FlutterSecureStorage().read(key: 'Value');

//     if (valueToToken != null) {
//       if (kDebugMode) {
//         print("SessionToken is Stored : $valueToToken");
//       }
//     } else {
//       if (kDebugMode) {
//         print('Session Token is not Stored');
//       }
//     }
//   }

//   Future<void> data_write_function(Map<String, dynamic> decodedResponse) async {
//     final valueToStore = decodedResponse['Value'].toString();
//     await const FlutterSecureStorage()
//         .write(key: 'StoredValue', value: valueToStore);
//   }

//   Future<String?> get_stored_data() async {
//     String? storedValue =
//         await const FlutterSecureStorage().read(key: 'StoredValue');
//     return storedValue;
//   }

//   Future<void> check_stored_data() async {
//     String? storedValue =
//         await const FlutterSecureStorage().read(key: 'StoredValue');

//     if (storedValue != null) {
//       if (kDebugMode) {
//         print('Data is stored: $storedValue');
//       }
//     } else {
//       if (kDebugMode) {
//         print('Data is not stored.');
//       }
//     }
//   }

//   Future<void> write_devicecount(int num) async {
//     final valueToStore = num.toString();
//     await const FlutterSecureStorage()
//         .write(key: 'devicecount', value: valueToStore);
//   }

//   Future<String?> get_devicecount() async {
//     String? storedValue =
//         await const FlutterSecureStorage().read(key: 'devicecount');
//     return storedValue;
//   }

//   Future<void> write_error_code(String? error) async {
//     final errortype = error;
//     await const FlutterSecureStorage()
//         .write(key: 'ErrorCode', value: errortype);
//   }

//   Future<String?> get_error_code() async {
//     String? errortype =
//         await const FlutterSecureStorage().read(key: 'ErrorCode');
//     return errortype;
//   }
